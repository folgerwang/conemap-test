#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#include "global_definition.glsl.h"
#include "prt_core.glsl.h"

layout(push_constant) uniform ConemapUniformBufferObject {
    ConemapGenParams params;
};

#define kSampleAngleStep (2.0f * PI / 1024.0f)

layout(set = 0, binding = SRC_TEX_INDEX) uniform sampler2D src_img;
layout(set = 0, binding = SRC_INFO_TEX_INDEX, rg16f) uniform readonly image2D minmax_depth_img;
layout(set = 0, binding = DST_TEX_INDEX, r32i) uniform iimage2D dst_img_0;
layout(set = 0, binding = DST_TEX_INDEX_1, r32i) uniform iimage2D dst_img_1;

const ivec2 g_dispatch_size =
    ivec2(kConemapGenDispatchX, kConemapGenDispatchY);
const ivec2 g_cache_block_size =
    ivec2(kConemapGenBlockCacheSizeX, kConemapGenBlockCacheSizeY);

const uint kConemapGenBlockCacheSize = kConemapGenBlockCacheSizeX * kConemapGenBlockCacheSizeY;
const uint kDispatchSize = kConemapGenDispatchX * kConemapGenDispatchY;

shared float s_depth[kConemapGenBlockCacheSize];

int getSamplePixelIndex(vec2 sample_pixel) {
    ivec2 i_sample_pixel = ivec2(sample_pixel);
    return i_sample_pixel.y * g_cache_block_size.x + i_sample_pixel.x;
}

layout(local_size_x = kConemapGenDispatchX, local_size_y = kConemapGenDispatchY) in;
void main()
{
    ivec2 local_pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 global_pixel_coords = params.dst_block_offset + local_pixel_coords;
    ivec2 local_group_idx = ivec2(gl_WorkGroupID);
    ivec2 global_group_offset = params.dst_block_offset + local_group_idx * g_dispatch_size;
    ivec2 center_cache_block_idx = global_group_offset / g_cache_block_size;
    uint local_idx = gl_LocalInvocationIndex;

    while (local_idx < kConemapGenBlockCacheSize) {
		ivec2 cache_block_coords = ivec2(local_idx % g_cache_block_size.x, local_idx / g_cache_block_size.x);
		ivec2 cache_coords = params.cache_block_offset + cache_block_coords;
		s_depth[local_idx] = texture(src_img, (cache_coords + 0.5f) * params.inv_full_size)[params.depth_channel];
        local_idx += kDispatchSize;
	}

/*    if (local_pixel_coords.x < kConemapGenBlockCacheSizeX && local_pixel_coords.y < kConemapGenBlockCacheSizeY) {
		ivec2 cache_coords = params.cache_block_offset + local_pixel_coords;
        uint cache_idx = local_pixel_coords.y * g_cache_block_size.x + local_pixel_coords.x;
		s_depth[cache_idx] = texture(src_img, (cache_coords + 0.5f) * params.inv_full_size)[params.depth_channel];
	}*/

    memoryBarrierShared();
    groupMemoryBarrier();

    // get index in global work group i.e x,y position
    vec2 uv = (global_pixel_coords.xy + 0.5f) * params.inv_full_size;
    float c_depth = texture(src_img, uv)[params.depth_channel];

    bool skip_this_group = false;
    // if this dispatch group is within 3x3 cache blocks, means it has been processed, skip it.
    if (params.cache_block_index.x >= center_cache_block_idx.x - 1 &&
        params.cache_block_index.x <= center_cache_block_idx.x + 1 &&
        params.cache_block_index.y >= center_cache_block_idx.y - 1 &&
        params.cache_block_index.y <= center_cache_block_idx.y + 1) {
        skip_this_group = true;
    }

    ivec2 box_corner_min = params.cache_block_offset;
    ivec2 box_corner_max = box_corner_min + g_cache_block_size - 1;
    box_corner_max = clamp(box_corner_max, ivec2(0), ivec2(params.full_size - 1));

    ivec2 close_dist_0 = max(global_group_offset - box_corner_max, ivec2(0));
    ivec2 close_dist_1 = max(box_corner_min - (global_group_offset + g_dispatch_size), ivec2(0));
    float closest_c_t = length(vec2(close_dist_0 + close_dist_1));

    float saved_conemap_info = intBitsToFloat(imageLoad(dst_img_0, local_pixel_coords).x);
    vec2 minmax_depth = imageLoad(minmax_depth_img, params.cache_block_index).xy;

    float buffer_diagonal_length = length(vec2(params.full_size));
    float inv_cone_ratio = (max(c_depth - minmax_depth.x, 0.0f) * buffer_diagonal_length) / closest_c_t;

    // if the conservative cone ratio of cached block is smaller than the saved one, skip this group.
    if (inv_cone_ratio <= saved_conemap_info) {
		skip_this_group = true;
	}

    if (!skip_this_group) {
        ivec2 ray_00 = box_corner_min - global_pixel_coords;
        ivec2 ray_11 = box_corner_max - global_pixel_coords;
        ivec2 ray_01 = ivec2(ray_00.x, ray_11.y);
        ivec2 ray_10 = ivec2(ray_11.x, ray_00.y);

        float angle_00 = getAngle(ray_00);
        float angle_01 = alignAngle(getAngle(ray_01), angle_00);
        float angle_10 = alignAngle(getAngle(ray_10), angle_00);
        float angle_11 = alignAngle(getAngle(ray_11), angle_00);

        float start_angle = min(min(angle_01, angle_10), min(angle_00, angle_11));
        float end_angle = max(max(angle_01, angle_10), max(angle_00, angle_11));

        uint num_sample_rays = uint(max((end_angle - start_angle) / kSampleAngleStep, 1));

        float angle_step = (end_angle - start_angle) / float(num_sample_rays);

        vec4 best_inv_cone_ratio = vec4(0.0f);

        float alpha = start_angle + 0.5f * angle_step;
        vec2 ray_org = global_pixel_coords.xy + 0.5f;
        for (uint ta = 0; ta < num_sample_rays; ta++) {
            vec2 sample_ray = vec2(cos(alpha), sin(alpha));
            vec2 t = getIntersection(ray_org, sample_ray, box_corner_min, box_corner_max);
            float t_range = t.y - t.x;

            if (t_range > 0) {
                vec2 sample_ray_start = ray_org + t.x * sample_ray - params.cache_block_offset;
                vec2 sample_ray_end = ray_org + t.y * sample_ray - params.cache_block_offset;

                sample_ray_start = min(max(sample_ray_start, vec2(0.0f)), vec2(g_cache_block_size - 1));
                sample_ray_end = min(max(sample_ray_end, vec2(0.0f)), vec2(g_cache_block_size - 1));

                vec2 sample_ray_range = sample_ray_end - sample_ray_start;
                uint sample_count =
                    uint(max(max(abs(sample_ray_range.x), abs(sample_ray_range.y)), 1.0f));

                float t_step = t_range / float(sample_count);
                vec2 sample_ray_step = sample_ray_range / float(sample_count);

                float c_t = t.x + 0.5f * t_step;
                vec2 sample_pixel = sample_ray_start + 0.5f * sample_ray_step;
                int idx_prev = getSamplePixelIndex(min(max(sample_pixel - sample_ray_step, vec2(0)), vec2(g_cache_block_size - 1)));
                float s_d_prev = s_depth[idx_prev];
                int idx = getSamplePixelIndex(min(max(sample_pixel, vec2(0)), vec2(g_cache_block_size - 1)));
                float s_d = s_depth[idx];
                for (uint ts = 0; ts < sample_count; ts++) {
                    sample_pixel += sample_ray_step;
                    int idx_next = getSamplePixelIndex(min(max(sample_pixel, vec2(0)), vec2(g_cache_block_size - 1)));
                    float s_d_next = s_depth[idx_next];

                    float deta_height = s_d / c_t * t_step;
                    // found tangent point.
                    float inv_cone_ratio = (max(c_depth - s_d, 0.0f) * buffer_diagonal_length) / c_t;
                    if (s_d_prev >= s_d - deta_height && s_d_next >= s_d + deta_height) {
                        best_inv_cone_ratio.x = max(best_inv_cone_ratio.x, inv_cone_ratio);
                    }

                    best_inv_cone_ratio.y = max(best_inv_cone_ratio.y, inv_cone_ratio);
	                s_d_prev = s_d;
			        s_d = s_d_next;
                    c_t += t_step;
		        }
            }

            alpha += angle_step;
        }

	    // output to a specific pixel in the image.
	    imageAtomicMax(dst_img_0, local_pixel_coords, floatBitsToInt(best_inv_cone_ratio.x));
        imageAtomicMax(dst_img_1, local_pixel_coords, floatBitsToInt(best_inv_cone_ratio.y));
    }
}